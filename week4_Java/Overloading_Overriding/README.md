# Overloading vs. Overriding

------

## 1. Overloading

### 1. 정의 : 같은 이름의 메소드 또는 생성자를 매개변수의 개수나 타입을 다르게 지정함으로써 2개 이상 정의하는 것

- 자바(Java) 에서는 원래 한 클래스 내에 동일한 이름을 갖는 메소드를 둘 이상 가질 수 없다.
- 하지만, 한 클래스 내에 동일한 이름을 갖는 메소드를 여러개 선언하여 <u>매개변수의 타입 또는 개수, 순서</u>를 달리해 사용 가능
- 객체 지향 프로그래밍의 특징 중 하나인 다형성(ploymorphism)을 구현하는 방법 중 하나.

------

$ **메소드 시그니처(method signature)**

- 메소드 오버로딩의 핵심
- 정의 : 메소드의 선언부에 명시되는 매개변수의 **리스트**
- 두 메소드가 매개변수의 개수, 타입, 순서까지 같으면, **두 메소드의 시그니처는 같다**고 할 수 있다.
- 참고로, <u>**Java 컴파일러**</u>는 메소드 이름과 메소드 시그니처를 통해 메소드 간의 차이를 식별한다.
- => **오버로딩된 메소드는 컴파일(Complie) 시에 어떤 메소드를 실행할지 결정한다.**

------

다시 돌아와서 즉, 메소드 오버로딩은 **서로 다른 시그니처를 갖는 여러 메소드를 같은 이름으로 정의**하는 것

- 효과
  1. 메소드에 사용되는 이름을 절약할 수 있다.
  2. 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있다.

### 2. 메소드 오버로딩의 조건

	1. 메소드의 이름이 같아야 한다.
 	2. 메소드의 시그니처, 즉 매개변수의 개수 또는 타입, 순서가 달라야 한다.
     - 참고로 매개변수의 이름은 오버로딩에 영향을 주지 않는다. 타입과 개수가 같고 이름만 다르면 오버로딩이 성립하지 않는다.

- 참고로 메소드 오버로딩은 리턴 타입과 관계과 없다. 메소드 시그니처가 같고 리턴 타입만 다른 것은 오버로딩이 성립하지 않는다.



### 3. 메소드 오버로딩 예제

Java 컴파일러는 사용자가 오버로딩된 함수를 호출하면, 전달된 매개변수의 개수와 타입과 같은 시그니처를 가지는 메소드를 찾아 호출한다.

```java
class Test {

  	// 1번 전달받은 num1을 그대로 출력
    static void display(int num1) { System.out.println(num1); }	 

  	// 2번 전달받은 두 정수의 곲을 출력함
    static void display(int num1, int num2) { System.out.println(num1 * num2); }	

  	// 3번 전달받은 정수와 실수의 합을 출력
    static void display(int num1, double num2) { System.out.println(num1 + num2); }	

}

 
public class Method06 {

    public static void main(String[] args) {

        Test myfunc = new Test();

 
        myfunc.display(10);	// 1번 display() 메소드 호출 -> 10

        myfunc.display(10, 20); // 2번 display() 메소드 호출 -> 200

        myfunc.display(10, 3.14); // 3번 display() 메소드 호출 -> 13.14

        myfunc.display(10, 'a'); // 2번과 3번 모두 호출 가능 -> 970

    }

}
```

사용자가 display() 메소드 호출 시, 컴파일러는 자동으로 같은 시그니처를 가지는 메소드를 찾아 호출

문제는 4번과 같이 첫 번째 인수로는 정수를, 두 번째 인수로는 실수를 전달받는 호출

**자바에서 char형 데이터는 int형 뿐만 아니라 double형으로도 타입 변환될 수 있기 때문**

따라서 이와 같은 호출은 자바 컴파일러가 어느 시그니처의 display() 메소드를 호출해야 할지 불명확하게 함.

자바에서는 오버로딩한 메소드의 이러한 **모호한 호출을 허용하지 않으며**, 위와 같은 경우에는 **더 작은 표현 범위**를 가지는 int형으로 자동 타입 변환하게 된다.



------

## 2. Overriding

### 1. 정의 : 상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 같은 시그니쳐를 갖는 메소드로 다시 정의하는 것

- Java 에서 자식 클래스는 부모 클래스의 private  멤버를 제외한 모든 메소드를 상속 받는다.

### 2. 오버라이딩 조건

 	1. 메소드의 동작만 재정의 하는 것이므로, **메소드의 선언부는 기존 메소드와 완전히 같아야 한다**.
     - 메소드의 반환 타입은 부모 클래스의 반환 타입으로 타입 변환할 수 있는 타입이라면 변경할 수 있다.
	1. 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없다.
	1. 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없다.

### 3. 오버라이딩의 필요성

부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의 하는 것을 오버라이딩이라고 한다. 상속받은 메소드를 그대로 사용할 수도 있지만, **자식 클래스에서 상황에 맞게 변경해야 하는 경우 오버라이딩할 필요가 생긴다**. 오버라이딩을 하지 않을 시 이름을 다르게 해야하는데 그럼 **그 메소드가 여전히 살아있기 때문에 문제가 발생**할 수 있다. **알맞지 않은 기능은 못쓰게 해야 하기 때문에** 이 기능을 다른 기능으로 바꾸기 위하여 오버라이딩을 사용한다.

### 4. 오버라이딩 예제

```java
class Parent {

    void display() { System.out.println("부모 클래스의 display() 메소드입니다."); }

}

class Child extends Parent {

    // 오버라이딩된 display() 메소드

    void display() { System.out.println("자식 클래스의 display() 메소드입니다."); }

    void display(String str) { System.out.println(str); } // 오버로딩된 display() 메소드

}

 
public class Inheritance06 {

    public static void main(String[] args) {

        Child ch = new Child();

        ch.display();

        ch.display("오버로딩된 display() 메소드입니다.");

    }

}
// 실행 결과
// 자식 클래스의 display() 메소드입니다.
// 오버로딩된 display() 메소드입니다.
```



### 5. 오버라이딩 추가 내용

#### 오버라이딩에서 접근 제어자를 설정하는 규칙

1. 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다. 위에서 볼 수 있듯이 부모클래스의 접근제어자는 default로 설정되어 있다. 여기서 자식 클래스들은 default보다 같거나 더 넓은 범위의 접근제어자만 설정할 수 있으므로 default, protected, public 이 세 개의 접근 제어자는 사용이 가능하다.
2. 예외(Exception)는 부모 클래스의 메소드 보다 많이 선언할 수 없다.부모 클래스에서 어떤 예외를 throws 한다고 하면, 자식 클래스에서는 그 예외보다 더 큰 범위의 예외를 throws할 수 없다는 것이다.
3. static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다. 부모 클래스의 static메소드를 자식에서 같은 이름으로 정의할 수 있지만 이것은 다시 정의하는 것이 아니라 같은 이름의 static메소드를 새로 정의하는 것이다.

### Override 조건

- 부모 클래스와 자식 클래스 사이에서만 성립된다.

- static 메소드는 클래스에 속하는 메소드이기 때문에 상속되지 않고 오버라이드 되지도 않는다.

- private의 접근 제어자를 가진 메소드는 상속 자체가 되지 않아 오버라이드도 성립되지 않는다.

- interface를 구현하여 오버라이드할 때는 반드시 public 접근 제어자를 사용해야 한다.

- 오버로드와 달리 리턴 타입, 메소드명, 매개변수 패턴이 모두 같아야 한다.

- final이 지정된 메소드는 오버라이드 할 수 없다.

- 부모 클래스의 메소드의 접근 제한자 범위보다 작아질 수 없고 확장은 가능하다.

  - 부모의 public 접근제한 ->자식의 private, default 수정불가

  - 부모의 default 접근제한 ->자식의 default, public 수정가능

- 부모 클래스의 메소드보다 더 많은 예외를 던질 수 없다.(새로운 예외(Exception)를 throws(떠넘기기)할 수 없다.)
  - 예외의 개수 뿐만 아니라 상위의 예외의 경우, 개수가 적어보이지만 더 많은 예외를 처리할 수 있기 때문에 선언할 수 없게 된다.



------

## 요약

![1.png](/Users/kit938639/Documents/study/CS-Study/week4_Java/Overloading_Overriding/img/1.png)