# 생성 패턴

## 생성패턴이란

---

- 객체의 생성과 관련된 패턴
- 객체 **인스턴스를 만드는 과정을 추상화**하는 방법
- **생성 클래스 패턴**은 객체를 생성하는 일부를 서브클래스가 담당하도록 함.
- **생성 객체 패턴**은 객체 생성을 다른 객체에게 위임

<img src="./img/untitled.png">

## 싱글톤 패턴

---

### 개요

시스템안에서 어떤 **클래스의 인스턴스가 오직 하나임을 보장**하며, 이 인스턴스에 **접근할 수 있는 전역적인 접촉점을 제공**하는 패턴이다.

즉, 프로그램 시작부터 종료 시까지 어떤 클래스의 인스턴스가 메모리 상에 단 하나만 존재할 수 있으며, 이 인스턴스에 대해 어디에서나 접근할 수 있도록 하는 패턴이다.

### 사용 이유

개발을 하다보면 어떤 클래스에 대해 단 하나의 인스턴스만을 갖도록 하는 것이 좋은 경우가 있다. 예를 들어, 로그를 찍는(Logging) 객체라던가 쓰레드 풀, 윈도우 관리자 등 여러 객체를 관리하는 역할의 객체는 프로그램 내에서 단 하나의 인스턴스를 갖는 것이 바람직하다.

### 인스턴스 접근 방법

어디에서나 접근 가능한 영역으로 전역변수가 바로 떠오르지만, 더 좋은 방법은 **클래스 자신이 자기의 유일한 인스턴스로 접근하는 방법을 자체적으로 관리**하는 것이다.

쉽게 말해, 생성자를 private하게 만들어 클래스 외부에서는 인스턴스를 생성하지 못하게 차단하고, 내부에서 단 하나의 인스턴스를 생성하여 외부에는 그 인스턴스에 대한 접근 방법을 제공할 수 있습니다.

### 구현 방법

```java
public class Singleton {
    private static Singleton singleton  = new Singleton();

    private Singleton() {
        System.out.println("created Singleton");
    }
    public static Singleton getInstance(){
        return singleton;
    }
}
```

- 생성자를 private로 작성하여 외부에서 절대 인스턴스 생성을 불가하게 한다.
- 클래스 내부에서 인스턴스를 하나 만들고, 메소드를 통해 해당 인스턴스를 꺼내는 방식으로 객체를 사용한다.
- 위의 방법은 가장 간단한 형태의 구현 방법이다. 이 방법은 해당 객체를 사용하지 않아도 메모리를 점유한다는 단점이 있다.
- 단점을 보완한 다양한 방법이 있고, 그것은 아래의 링크에서 확인하자

[[생성 패턴] 싱글톤(Singleton) 패턴을 구현하는 6가지 방법](https://readystory.tistory.com/116)

- 아래의 구현은 현재 가장 널리 쓰이는 방식이다. 대부분의 오픈소스도 아래의 방식을 사용한다.

\***\*Bill Pugh Singleton Implementaion\*\***

```java
public class Singleton {

    private Singleton(){}

    private static class SingletonHelper{
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance(){
        return SingletonHelper.INSTANCE;
    }
}
```

- 이 방법은 인스턴스가 메모리에 로드되는 타이밍도, 멀티 쓰레딩 방지를 위한 synchronized사용으로 인한 효율 감소도 없는 방법이다.
- 하지만 자바 Reflection으로 싱글톤의 파괴가 가능하다는 단점이 있다.

### 장점

1. 외부에서 생성할 수 없다.
2. 고정된 영역에 미리 할당한다.('static area')
3. 고정된 영역에 할당하기에 메모리를 낭비하지 않는다.
4. JVM이 종료되기 전까지 계속 사용할 수 있다.

## 빌더패턴

---

### 정의

**빌더 패턴**은 복잡한 **객체를 생성하는 방법을 정의하는 클래스와 표현하는 방법을 정의하는 클래스를 별도로 분리**하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴이다. \*\*\*\*

여기서는 이펙티브 자바의 내용을 기반으로 하는 빌더 패턴의 필요성과 작성법에 대한 내용을 설명한다.

### 필요성

> **“생성자에 매개변수가 많다면 빌더패턴을 고려해볼 것”** - 이펙티브 자바 -

<img src="./img/untitled1.png">

위의 사진은 User객체이다. 이 객체의 인스턴스를 필드값과 함께 생성할 때, 기본적으로 다음과 같은 방법으로 생성한다.

1. **생성자로 파라미터와 함께 생성**

   <img src="./img/untitled2.png">
   위와 같이 생성자를 만들고, 그 생성자에 필드 값들을 채워 넣어주며 객체를 만든다.

   하지만 이러한 방식은 **2가지의 단점**이 존재한다.

   - **User객체 생성 시, 어떤 위치에 어떤 Arguments를 넘겨줘야 하는지 구분이 어렵다.**
       <img src="./img/untitled3.png">
       
       (위의 예시에서 만약 IDE가 없었다면 age위치에 height를 넣는 실수를 할 가능성이 있다.)

   - **만약 객체를 생성할 때마다 요구되는 필드값이 다른 경우, 해당 case에 맞는 생성자를 전부 만들어줘야한다.**
       <img src="./img/untitled4.png">
       
       <img src="./img/untitled5.png">
       
       해당 생성자를 만들지 않고, null값을 채워줄 수도 있지만 그 또한 개발자의 실수를 유발할 수 있는 좋지 않은 생성 방식이다.


2. **생성 후 Setter주입**

   <img src="./img/untitled6.png">

   <img src="./img/untitled7.png">

   이 방법은 객체 생성 시 주입되는 파라미터가 매번 다른 경우에도 setter를 통해 유연하게 코드를 짤 수 있는 장점이 있다.

   하지만, User객체는 생성되는 순간이 아닌 Setter가 끝나는 순간에야 완전한 객체가 된다. 이것이 문제가 되는 이유는 User객체가 생성되고 setter로 필수 필드값을 채워주기 전에 사용해도 컴파일 오류가 발생하지 않기 때문이다.

   또한, Setter는 public메소드이므로 필드값의 불변을 보장할 수 없다. (final키워드 사용 불가)

   (생성자 방식은 객체 생성과 동시에 필드값을 채워주므로 필드를 final로 선언하면 불변을 보장할 수 있다.)

   **이러한 단점들을 보완하는 생성 패턴이 바로 빌더패턴이다.**

   <img src="./img/untitled8.png">

   (이 경우는 하나의 예시이고 다른 방법으로 구현도 가능하다. 예제를 위해 필드의 개수를 3개로 줄였다.)

   Builder클래스 작성 부분에서 유의깊게 볼 부분은 다음과 같다.

   - Builder라는 Inner Class
   - Inner Class안의 필드값을 채워주는 메소드는 this, 즉 Builder자신을 리턴한다. 이는 체이닝으로 필드값을 채울 수 있게 해준다.
   - 마지막에 User객체를 생성해주는 build메소드가 있다. 만약 어떤 필드의 값은 Builder메소드로 채워주지 않았다면 자동으로 기본값(null, 0)이 필드값으로 채워진다.

   위의 예시처럼 클래스를 작성하면 객체 생성을 다음과 같은 방법으로 할 수 있다.

<img src="./img/untitled9.png">

위에서 단점으로 지적한 부분은 크게 2가지였다.

1. 필드가 많고, 객체 생성 마다 주입하는 필드의 값이 다른 경우 생성자 코드가 많아지고 복잡해진다.
2. setter로 필드값을 주입하는 경우는 객체 생성과 동시에 객체의 완전함을 보장할 수 없었다.

하지만 위의 Builder패턴은 생성과 동시에 필드값을 채워줄 수 있음과 동시에, 필드값을 채우는 다양한 경우의 수를 고려한 생성자를 만들지 않아도 된다.

### 참고자료

[디자인패턴 빌더 - 곽동운 | 백엔드 데브코스 2기 | 백둥이Deview 220406](https://youtu.be/BCI4mLPsJUk)
